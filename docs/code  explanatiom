 This is research-level code
 UART + FSM integration is strong
 Good for FPGA, VLSI, Embedded Systems portfolios





Overall Big Picture (What this design does)

This design combines two systems:

ğŸ…° Smart Parking Controller (FSM)

Uses IR sensors (ir0â€“ir3)

Controls traffic lights

Controls parking slots

Drives a motor (gate open / close)

ğŸ…± UART Receiver (RS-232)

Receives 40-bit serial data

Stores it in receive_data

Uses UART FSM (start bit, data bits, stop bit)

Uses received data to make decisions in parking FSM

So in short:

UART data + IR sensors â†’ FSM â†’ lights, parking status, motor control

2ï¸âƒ£ Module main â€” The Real Hardware Design
ğŸ”¹ Inputs & Outputs
Inputs
reset, clk                  // system reset & clock
ir0, ir1, ir2, ir3           // IR sensors
sw_0, sw_limit               // limit switches (gate control)
id                           // ID input (unused mostly)
RS232_DCE_RXD                // UART RX line
Outputs
RS232_DCE_TXD                // UART TX (loopback)
receive_data[39:0]           // received UART data
orng, red, green, yellow     // traffic lights
park_lot[2:0]                // parking slot availability
motor_cw, motor_ccw          // gate motor direction

ğŸ“Œ Loopback

assign RS232_DCE_TXD = RS232_DCE_RXD;

Whatever comes in RX goes out TX.

3ï¸âƒ£ UART Receiver Section (Very Important)
â± Timing Parameters
parameter rcv_bit_per = 2604;
parameter half_rcv_bit_per = 1302;

These define baud rate timing (based on clock frequency).

UART FSM States
ready â†’ start_bit â†’ data_bits â†’ stop_bit

This is a standard UART FSM.

UART Registers
rcv_sr           // shift register (40-bit)
counter          // baud timing counter
data_bit_count   // number of bits received
p_state          // present UART state
n_state          // next UART state
UART FSM Logic
always @(p_state, RS232_DCE_RXD, counter, data_bit_count)
ğŸ”¸ ready

Waits for RX line to go LOW (start bit)

ğŸ”¸ start_bit

Waits half bit time

Confirms valid start bit

ğŸ”¸ data_bits
n_rcv_sr <= {RS232_DCE_RXD, rcv_sr[39:1]};

Shifts incoming bits into a 40-bit register

After 40 bits â†’ go to stop bit

ğŸ”¸ stop_bit

Waits one bit time

Returns to ready

UART Register Update
always @(posedge clk)

This block updates:

UART state

Shift register

Counters

4ï¸âƒ£ Parking System FSM (Main Logic)
FSM States
STATE_S0 â†’ STATE_S8

This FSM controls:

Lights

Parking slots

Gate motor

ğŸ”¹ Important Signals
Space Calculation
assign space = (ir1 + ir2 + ir3);

If space == 0 â†’ parking available

If space == 1 â†’ parking full

ğŸ”¹ State Transitions (Simplified Meaning)
ğŸŸ¢ STATE_S0 â€“ Idle / Reset

All lights ON

Gate stopped

Parking slots free

ğŸŸ¡ STATE_S1 â€“ Check UART Data
if (receive_data == 93872914) â†’ STATE_S2
if (receive_data == 93872915) â†’ STATE_S3

â¡ UART decides what action to take

ğŸ”´ STATE_S2 â€“ Stop / Red Signal

Red ON

Gate stopped

ğŸš¦ STATE_S3 â€“ Check Parking Space
if (space == 0) â†’ STATE_S4
else â†’ STATE_S5
ğŸŸ¢ STATE_S4 â€“ Space Available

Yellow ON

Parking slot LEDs reflect IR sensors

ğŸš« STATE_S5 â€“ Parking Full

Green OFF

No entry allowed

âš™ STATE_S6 â€“ Gate Opening
motor_cw = 0;
motor_ccw = 1;
â›” STATE_S7 â€“ Gate Stop

Motor OFF

ğŸ”„ STATE_S8 â€“ Gate Closing
motor_cw = 1;
motor_ccw = 0;
5ï¸âƒ£ Output Logic (Lights, Parking, Motor)
always @(state)

This block:

Turns lights ON/OFF

Updates parking slots

Controls motor direction

ğŸ“Œ Example:

park_lot[0] <= ir1;
park_lot[1] <= ir2;
park_lot[2] <= ir3;

Each IR sensor shows slot occupied/free.

6ï¸âƒ£ Module test2 â€” Testbench (Simulation Only)

This part is NOT synthesized.

What it does:

Generates clock

Applies reset

Simulates IR sensors

Sends UART serial bits manually

Tests gate movement

Clock Generator
always #10 clk <= ~clk;

Creates a clock for simulation.

UART Simulation

All these:

#52090 RS232_DCE_RXD = 0;
#52090 RS232_DCE_RXD = 1;

Manually send UART bits bit-by-bit.

7ï¸âƒ£ How This Looks in a Paper (One-Line Summary)

â€œThe system integrates a 40-bit UART receiver with a finite state machine-based smart parking controller. Received serial data determines system states, while IR sensors dynamically monitor parking availability and control traffic lights and gate motors.â€
